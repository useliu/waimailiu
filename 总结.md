一。stylus语法
安装：npm i stylus stylus-loader --save-dev --legacy-peer-deps
配置：<style lang="stylus" rel="stylesheet/stylus">
创建stylus文件：xx.styl
如何父元素和子元素在一列上，样式没有效果
stylus注释 //

二、npm
# nodejs npm 参数 --save 的作用
    在项目下的package.json文件记录安装过的依赖包名称，当复制项目到另外的电脑上，只需运行命令: npm i 就能自动安装项目用到的依赖包。
# npm uninstall xxx删除某个库

三、vue
    slot卡槽：
        一、slot配合props使用
            父组件：1、引入子组件
                    2、components:{HeaderTop}
                    3、<子组件 title="显示内容"><子组件未显示的标签 slot="a" />（可以使用多个）</子组件>
            子组件：1、<子组件标签>title<子组件标签/>要显示的内容<子组件 title="显示内容">
                        子组件未显示的标签用slot占位<slot name="a" />（可以使用多个）
                    2、子组件及子组件未显示的标签样式
                    3、props:{title}
    路由：
        $router是用来操作路由的，$route是用来获取路由信息的。
        npm i stylus vue-router@3 --save --legacy-peer-deps
        配置路由main.js：
            引入路由：import router from './router'
            调用：new Vue({
                    el: '#app',
                    render: h => h(App),
                    router,
                })
        page文件夹放置路由组件
        router文件index.js文件:
            引入vue：import Vue from 'vue'
            引入路由：import VueRouter from 'vue-router'
            引入路由组件
            声明使用插件：Vue.use(VueRouter)
            暴露路由：
                export default new VueRouter({
                    routes:[
                        {
                            path:'/',
                            redirect:'/小写路径', 配置重定向
                        },{
                            path:'/小写路径',
                            component:首字母大写路径,
                            meta:['按时','删除'] meta路由元信息 也就是每个路由身上携带的信息。
                            meta:{ 控制公共组件的显示或隐藏
                                xx:true, 可以写多个
                            }
                        }
                    ]
                })
        组件：
            展示路由组件内容：<router-view></router-view>
            $route.path获取路由路径信息
            $router.back() 返回上一页
            this.$router.replace(path)替换当前路径
            注：script标签使用this.$route.xx
                template标签使用$route.xx
            meta显示与隐藏：$route.meta.xx
    Ajax请求函数模块：
        引入：import axios from 'axios'
        export default function ajax(url,data={},type='GET'){
            执行异步Ajax请求
            let promise
            if(type==='GET'){
                准备URL query参数数据
                let dataStr = '' // 数据拼接字符串(query参数)
                Object.key(data).forEach(key => {
                    dataStr += key + '=' + data[key] + '&'
                })
                if(dataStr !== ''){
                    dataStr = dataStr.substring(0,dataStr.lastIndexOf('&'))
                    url = url + '?' + dataStr // 地址+参数=完整地址
                }
                promise = axios.get(url) 发送get请求
            }else{
                promise = axios.post(url,data)
            }
            注：以上返回的是response，要得到数据需要response.data，所以需要在封装一个promise对象
            return new Promise(function(resolve,reject){
                promise.then(function(response){
                    resolve(response.data)
                }).catch(function(error){
                    reject(error)
                })
            })
        }
        Object.key(data) 成员是参数对象自身的（不含继承的）所有可遍历（ enumerable ）属性的键名。
            传入对象，返回属性名
            传入字符串，返回索引
            传入数组 返回索引
            构造函数 返回空数组或者属性名
        substring() 截取字符串
            substring(0,2)截取包含开始索引字符，不包含结束索引字符
            substring(2)这个表示截掉前两个，得到后边的新字符串。
        lastIndexOf(元素) 返回符合条件的倒数第一个索引值
    请求接口函数模块： 返回promise对象
        get请求：export const reqAddress = (参数) => ajax(`/path/${参数}`)
        post请求：export const reqAddress = (参数) => ajax(`/path/${参数}`)
        返单引号：``
        ${}作用：配合反单引号实现字符串拼接。代替以前传统复杂的引号双引号与+的拼接
        reqAddress=({参数1,参数2})和reqAddress=(参数1,参数2)区别：
            前一个返回一个对象，后一个返回两个数据
        `和'之间的区别：
            '或" 表示 string
            `表示模板字符串.模板字符串具有普通字符串不具备的一些功能.最重要的是，您可以获得插值
            模板字符串：`ab1`
            '：ab '+' 1

四、wiper 轮播图
    Swiper 5-6 vue-awesome-swiper@4.1.1 (Vue2)
    Swiper 4.x vue-awesome-swiper@3.1.0 (Vue2)
    Swiper 3.x vue-awesome-swiper@2.6.7 (Vue2)
    Swiper 4.x使用：
        npm i swiper@3.1.0 --save --legacy-peer-deps
        引入js：import Swiper from 'swiper'
        引入CSS：import 'swiper/dist/css/swiper.min.css'
        使用：
            mounted(){
                // 创建一个swiper实例对象，实现轮播
                new Swiper('.swiper-container',{
                    loop:true, // 可以循环轮播
                    // 如果需要分页器
                    pagination:{
                        el:'.swiper-pagination',
                        clickable:true
                    }
                })
            },
            注：HTML标签的CSS选择名

五、Git版本控制
    创建仓库：
        git init: 建立一个标准的git仓库
            这样的仓库初始化后，其项目目录为工作空间，其下的.git目录是版本控制器。可以正常的进行源文件的编写，提交等各种git常规操作。
            git init命令执行后会在本地生成一个 .git 的文件夹，用来追踪仓库的所有变更。
        git init --bare: 指定某个目录成为中心仓库（裸仓库）
            使用git init --bare <repo>：建立一个“裸”的gt仓库。这样的仓库初始化后，其项目目录下就是标准仓库.git目录里的内容，没有工作空间。
            这个仓库只保存git历史提交的版本信息，而不允许用户在上面进行各种git操作（如：push、commit操作）。但是，你依旧可以使用git show命令查看提交内容。
        git init创建的仓库可以进行操作，git init --bare只能进行查看
    git add .添加所有文件、文件夹和子文件夹，包括.gitignore和以点开头的任何其他内容
    git add *将添加除以点开头的文件、文件夹和子文件夹以外的任何文件、文件夹和子文件夹。
    如果文件在子目录中，git add *仍然会添加以点开头的文件。
    git add .也尊重.gitignore，而git add *会在任何非点文件被gitignore时抛出一个错误。
    *不是git的一部分，它是shell解释的通配符。*扩展到当前目录中的所有文件，然后才传递给git，git是add的全部文件。.是当前目录本身，git add将添加它和它下面的所有文件。 